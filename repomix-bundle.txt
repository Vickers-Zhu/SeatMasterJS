// Generated by rpmix on 2025-04-14T06:13:26.833Z

// File: src/infrastructure/theme/spacing.js
export const lineHeights = {
    title: '28px',
    copy: '20px',
  };
  
  export const space = ['0px', '4px', '8px', '16px', '32px', '64px'];
  

// File: src/infrastructure/theme/sizes.js
export const sizes = ['8px', '16px', '32px', '64px', '128px'];


// File: src/infrastructure/theme/index.js
import { colors } from './colors';
import { sizes } from './sizes';
import { space, lineHeights } from './spacing';
import { fonts, fontWeights, fontSizes } from './fonts';

export const theme = {
  colors,
  sizes,
  space,
  lineHeights,
  fonts,
  fontSizes,
  fontWeights,
};


// File: src/infrastructure/theme/fonts.js
export const fonts = {
  body: "Oswald_400Regular",
  heading: "Lato_400Regular",
  monospace: "Oswald_400Regular",
};

export const fontWeights = {
  regular: 400,
  medium: 500,
  bold: 700,
};

export const fontSizes = {
  caption: "12px",
  button: "14px",
  body: "16px",
  title: "20px",
  h5: "24px",
  h4: "34px",
  h3: "45px",
  h2: "56px",
  h1: "112px",
};


// File: src/infrastructure/theme/colors.js
export const colors = {
  brand: {
    primary: "#FFFFFF",
    secondary: "#757575",
    muted: "#C6DAF7",
  },
  ui: {
    primary: "#262626",
    secondary: "#757575",
    tertiary: "#F1F1F1",
    quaternary: "#FFFFFF",
    disabled: "#DEDEDE",
    error: "#D0421B",
    success: "#138000",
  },
  bg: {
    primary: "#FFFFFF",
    secondary: "#F1F1F1",
  },
  text: {
    primary: "#262626",
    secondary: "#757575",
    disabled: "#9C9C9C",
    inverse: "#FFFFFF",
    error: "#D0421B",
    success: "#138000",
  },
};


// File: src/features/customer/reservations/screens/ReservationFlow.js
// src/features/customer/reservations/screens/ReservationFlow.js
import React, { useState, useEffect, useRef, useCallback } from "react";
import {
  View,
  ScrollView,
  TouchableOpacity,
  Alert,
  FlatList,
} from "react-native";
import { MaterialIcons } from "@expo/vector-icons";
import { format, addDays, isSameDay, getDay } from "date-fns";
import { useNavigation, useRoute } from "@react-navigation/native";
import { CustomText } from "../../../../components/CustomText/CustomText";
import ReservationLayoutView from "../components/ReservationLayoutView";
import { TimeScroll } from "../../../../components/TimeScroll/TimeScroll";
import { Separator } from "../../../../components/Separator/Separator";
import { Spacer } from "../../../../components/Spacer/Spacer";
import { generateTimeSlots } from "../../../merchant/reservations/utils/timeUtils";
import * as Styles from "./ReservationFlow.styles";
import { BackButton } from "../../../../components/BackButton/BackButton";

const getDayAvailability = (date) => {
  const day = getDay(date);
  if (day === 0 || day === 6) return "medium";
  if (day === 1) return "unavailable";
  return "high";
};

const getWeekdayName = (date) => {
  const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  return days[getDay(date)];
};

const ReservationFlow = () => {
  const navigation = useNavigation();
  const route = useRoute();
  const { restaurant, existingReservation } = route.params || {};

  const dateScrollRef = useRef(null);
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [partySize, setPartySize] = useState(2);
  const [availableTimes, setAvailableTimes] = useState([]);
  const [selectedTime, setSelectedTime] = useState(null);
  const [showLayout, setShowLayout] = useState(false);
  const [selectedChairs, setSelectedChairs] = useState([]);
  const [notes, setNotes] = useState("");
  const [availability, setAvailability] = useState("high");
  const [scrollEnabled, setScrollEnabled] = useState(true);
  const [duration, setDuration] = useState(90);

  // Pre-fill form with existing reservation data if available
  useEffect(() => {
    if (existingReservation) {
      // Parse the date string to a Date object
      if (existingReservation.date) {
        try {
          const date = new Date(existingReservation.date);
          setSelectedDate(date);
        } catch (e) {
          console.error("Failed to parse date:", e);
        }
      }

      // Set party size
      if (existingReservation.people) {
        setPartySize(existingReservation.people);
      }

      // Set time
      if (existingReservation.time) {
        setSelectedTime(existingReservation.time);
      }

      // Set notes
      if (existingReservation.note) {
        setNotes(existingReservation.note);
      }

      // Set selected chairs
      if (existingReservation.chairs && existingReservation.chairs.length > 0) {
        setSelectedChairs(existingReservation.chairs);
        setShowLayout(true);
      }

      // Set duration
      if (existingReservation.duration) {
        setDuration(existingReservation.duration);
      }
    }
  }, [existingReservation]);

  // Generate dates for selection
  const generateDates = useCallback(() => {
    const dates = [];
    const today = new Date();
    for (let i = 0; i < 60; i++) {
      const date = addDays(today, i);
      const availability = getDayAvailability(date);
      dates.push({
        date,
        label: i === 0 ? "Today" : i === 1 ? "Tomorrow" : format(date, "MMM d"),
        weekday: getWeekdayName(date),
        availability,
        isUnavailable: availability === "unavailable",
      });
    }
    return dates;
  }, []);

  // Generate party size options based on restaurant settings
  const generatePartySizeOptions = useCallback(() => {
    const maxPartySize = restaurant?.settings?.maxReservationSize || 20;
    return Array.from({ length: maxPartySize }, (_, i) => i + 1);
  }, [restaurant?.settings?.maxReservationSize]);

  const [dateOptions] = useState(generateDates);
  const [partySizeOptions] = useState(generatePartySizeOptions);

  // Update available time slots based on selected date
  useEffect(() => {
    const allSlots = generateTimeSlots();
    const dayOfWeek = getDay(selectedDate);
    let filteredTimes;

    // Different hours for weekends vs weekdays
    if (dayOfWeek === 0 || dayOfWeek === 6) {
      // Weekend
      filteredTimes = allSlots.filter((time) => {
        const hour = parseInt(time.split(":")[0]);
        return hour >= 10 && hour <= 22;
      });
    } else {
      // Weekday
      filteredTimes = allSlots.filter((time) => {
        const hour = parseInt(time.split(":")[0]);
        return hour >= 11 && hour <= 21;
      });
    }

    setAvailableTimes(filteredTimes);

    // Set default time if none selected or current selection isn't available
    if (!selectedTime || !filteredTimes.includes(selectedTime)) {
      const defaultTimeIndex = Math.floor(filteredTimes.length / 2);
      setSelectedTime(filteredTimes[defaultTimeIndex]);
    }
  }, [selectedDate]);

  // Update availability and duration based on party size and time
  useEffect(() => {
    if (!selectedTime) return;

    const hour = parseInt(selectedTime.split(":")[0]);

    // Determine availability level based on party size and time
    if (partySize > 10) {
      setAvailability("low");
    } else if ((hour >= 18 && hour <= 20) || partySize > 6) {
      setAvailability("medium");
    } else {
      setAvailability("high");
    }

    // Set duration based on party size
    if (partySize >= 8) {
      setDuration(120);
    } else if (partySize >= 4) {
      setDuration(90);
    } else {
      setDuration(60);
    }
  }, [selectedTime, partySize]);

  // Reset chair selection when party size or time changes
  useEffect(() => {
    // Only reset chairs if the user hasn't explicitly chosen seats
    if (!existingReservation) {
      setSelectedChairs([]);
    }
  }, [partySize, selectedTime]);

  // Handlers for interaction with the 3D layout
  const handleInteractionStart = useCallback(() => {
    setScrollEnabled(false);
  }, []);

  const handleInteractionEnd = useCallback(() => {
    setScrollEnabled(true);
  }, []);

  // Handle chair selection from the 3D layout
  const handleChairSelection = useCallback((chairIds) => {
    if (chairIds) {
      setSelectedChairs(chairIds.split(","));
      console.log("Selected chairs in reserv flow:", chairIds.split(","));
    } else {
      setSelectedChairs([]);
    }
  }, []);

  // Generate a unique reservation ID
  const generateReservationId = () => {
    return Math.floor(Math.random() * 10000) + 1;
  };

  // Handle the reservation submission
  const handleReservePress = useCallback(() => {
    if (!selectedDate || !selectedTime) {
      Alert.alert(
        "Missing Information",
        "Please select a date and time for your reservation."
      );
      return;
    }

    // Validate chair selection if layout is shown
    if (showLayout && selectedChairs.length > 0) {
      if (selectedChairs.length < partySize) {
        Alert.alert(
          "Seat Selection Required",
          `Please select ${partySize} seats. You have selected ${selectedChairs.length}.`
        );
        return;
      }
    }

    const customerName = "Current User";
    const reservationDetails = {
      id: existingReservation?.id || generateReservationId(),
      customerName,
      restaurant: restaurant,
      date: format(selectedDate, "yyyy-MM-dd"),
      time: selectedTime,
      people: partySize,
      duration: duration,
      status: "confirmed",
      note: notes,
    };

    // Include chair information if chairs were selected
    if (selectedChairs.length > 0) {
      reservationDetails.chairs = selectedChairs;
    } else {
      reservationDetails.autoAssigned = true;
    }

    // Determine if this is a new or modified reservation
    const isModification = !!existingReservation;
    const title = isModification
      ? "Reservation Updated!"
      : "Reservation Confirmed!";
    const message = `Your reservation for ${partySize} ${
      partySize > 1 ? "people" : "person"
    } at ${selectedTime} on ${format(selectedDate, "EEE, MMM d")} has been ${
      isModification ? "updated" : "confirmed"
    }.${
      selectedChairs.length === 0
        ? "\n\nYour seats will be assigned upon arrival."
        : ""
    }`;

    // Confirm the reservation
    Alert.alert(title, message, [
      {
        text: "OK",
        onPress: () => {
          // Navigate back to the Reservations screen
          navigation.navigate("ReservationsScreen");
        },
      },
    ]);
  }, [
    selectedDate,
    selectedTime,
    partySize,
    duration,
    selectedChairs,
    showLayout,
    notes,
    restaurant,
    existingReservation,
    navigation,
  ]);

  // Render availability legend
  const renderAvailabilityLegend = () => (
    <View style={{ flexDirection: "row", marginTop: 8, marginBottom: 16 }}>
      <Styles.AvailabilityRow>
        <View
          style={{
            width: 10,
            height: 10,
            borderRadius: 5,
            backgroundColor: "#4CAF50",
            marginRight: 4,
          }}
        />
        <Styles.AvailabilityText>High</Styles.AvailabilityText>
      </Styles.AvailabilityRow>
      <Styles.AvailabilityRow style={{ marginLeft: 12 }}>
        <View
          style={{
            width: 10,
            height: 10,
            borderRadius: 5,
            backgroundColor: "#FFC107",
            marginRight: 4,
          }}
        />
        <Styles.AvailabilityText>Limited</Styles.AvailabilityText>
      </Styles.AvailabilityRow>
      <Styles.AvailabilityRow style={{ marginLeft: 12 }}>
        <View
          style={{
            width: 10,
            height: 10,
            borderRadius: 5,
            backgroundColor: "#F44336",
            marginRight: 4,
          }}
        />
        <Styles.AvailabilityText>Few spots</Styles.AvailabilityText>
      </Styles.AvailabilityRow>
    </View>
  );

  return (
    <Styles.Container scrollEnabled={scrollEnabled}>
      <Styles.HeaderContainer>
        <CustomText variant="h4">
          {existingReservation ? "Modify Reservation" : "Make a Reservation"}
        </CustomText>
      </Styles.HeaderContainer>

      {/* Date Selector */}
      <Styles.DateSelectorContainer>
        <Styles.SectionTitle>Date</Styles.SectionTitle>
        <Styles.DateItemsContainer>
          <FlatList
            ref={dateScrollRef}
            horizontal
            showsHorizontalScrollIndicator={false}
            data={dateOptions}
            keyExtractor={(item, index) => `date-${index}`}
            renderItem={({ item }) => (
              <Styles.DateOption
                selected={isSameDay(selectedDate, item.date)}
                unavailable={item.isUnavailable}
                onPress={() =>
                  !item.isUnavailable && setSelectedDate(item.date)
                }
              >
                <Styles.DateText selected={isSameDay(selectedDate, item.date)}>
                  {item.label}
                </Styles.DateText>
                <Styles.WeekdayText
                  selected={isSameDay(selectedDate, item.date)}
                >
                  {item.weekday}
                </Styles.WeekdayText>
                {!item.isUnavailable && (
                  <Styles.AvailabilityIndicator
                    level={item.availability}
                    selected={isSameDay(selectedDate, item.date)}
                  />
                )}
              </Styles.DateOption>
            )}
            initialNumToRender={7}
            maxToRenderPerBatch={10}
          />
        </Styles.DateItemsContainer>
      </Styles.DateSelectorContainer>

      {/* Party Size Selector */}
      <Styles.PartySelectorContainer>
        <Styles.SectionTitle>Party Size</Styles.SectionTitle>
        <ScrollView horizontal showsHorizontalScrollIndicator={false}>
          <Styles.PartyOptionsContainer>
            {partySizeOptions.map((size) => (
              <Styles.PartyOption
                key={`size-${size}`}
                selected={partySize === size}
                onPress={() => setPartySize(size)}
              >
                <Styles.PartyText selected={partySize === size}>
                  {size}
                </Styles.PartyText>
              </Styles.PartyOption>
            ))}
          </Styles.PartyOptionsContainer>
        </ScrollView>
      </Styles.PartySelectorContainer>

      {/* Time Selector */}
      <Styles.TimeContainer>
        <Styles.SectionTitle>Time</Styles.SectionTitle>
        <ScrollView horizontal showsHorizontalScrollIndicator={false}>
          <Styles.TimeOptionsContainer>
            {availableTimes.map((time, index) => {
              const hour = parseInt(time.split(":")[0]);
              let timeAvailability = "high";
              if (hour >= 18 && hour <= 20) {
                timeAvailability = "medium";
              } else if (hour === 21) {
                timeAvailability = "low";
              }
              return (
                <Styles.TimeOption
                  key={`time-${index}`}
                  selected={selectedTime === time}
                  availability={timeAvailability}
                  onPress={() => setSelectedTime(time)}
                >
                  <Styles.TimeText selected={selectedTime === time}>
                    {time}
                  </Styles.TimeText>
                  <Styles.TimeAvailabilityIndicator
                    level={timeAvailability}
                    selected={selectedTime === time}
                  />
                </Styles.TimeOption>
              );
            })}
          </Styles.TimeOptionsContainer>
        </ScrollView>
        {renderAvailabilityLegend()}
      </Styles.TimeContainer>

      <Separator type="full" />

      {/* Seat Selection Toggle */}
      <Styles.ToggleButton onPress={() => setShowLayout(!showLayout)}>
        <MaterialIcons
          name={showLayout ? "visibility-off" : "visibility"}
          size={24}
          color="#262626"
        />
        <Styles.ToggleText>
          {showLayout ? "Hide Seating Layout" : "Select Your Seats"}
        </Styles.ToggleText>
      </Styles.ToggleButton>

      {/* 3D Layout for Seat Selection */}
      {showLayout && (
        <Styles.LayoutContainer>
          <ReservationLayoutView
            onTableSelect={handleChairSelection}
            partySize={partySize}
            selectedTime={selectedTime}
            selectedDate={format(selectedDate, "yyyy-MM-dd")}
            onInteractionStart={handleInteractionStart}
            onInteractionEnd={handleInteractionEnd}
          />
        </Styles.LayoutContainer>
      )}

      {/* Special Requests */}
      <Styles.SectionTitle>Special Requests (Optional)</Styles.SectionTitle>
      <Styles.NotesInput
        multiline
        placeholder="Add any special requests or dietary requirements..."
        value={notes}
        onChangeText={setNotes}
        textAlignVertical="top"
      />

      {/* Reserve Button */}
      <Styles.ReserveButton onPress={handleReservePress}>
        <Styles.ReserveButtonText>
          {existingReservation ? "Update Reservation" : "Reserve Now"}
        </Styles.ReserveButtonText>
      </Styles.ReserveButton>

      <View style={{ height: 40 }} />
    </Styles.Container>
  );
};

export default ReservationFlow;


// File: /Users/vickerszhu/Projects/seat-master-js/src/components/CustomText/CustomText.js
import { Text } from "react-native";
import styled from "styled-components";

const defaultTextStyles = (theme) => `
  font-family: ${theme.fonts.body};
  font-weight: ${theme.fontWeights.regular};
  color: ${theme.colors.text.primary};
  flex-wrap: wrap;
  margin-top: 0px;
  margin-bottom: 0px;
`;
const title = (theme) => `
  font-size: ${theme.fontSizes.title};
  font-weight: ${theme.fontWeights.medium};
`;
const h5 = (theme) => `
  font-size: ${theme.fontSizes.h5};
`;
const h4 = (theme) => `
  font-size: ${theme.fontSizes.h4};
`;
const h3 = (theme) => `
  font-size: ${theme.fontSizes.h3};
`;
const h2 = (theme) => `
  font-size: ${theme.fontSizes.h2};
`;
const h1 = (theme) => `
  font-size: ${theme.fontSizes.h1};
`;

const body = (theme) => `
  font-size: ${theme.fontSizes.body};
`;

const hint = (theme) => `
  font-size: ${theme.fontSizes.body};
`;

const error = (theme) => `
  color: ${theme.colors.text.error};
`;

const caption = (theme) => `
  font-size: ${theme.fontSizes.caption};
  font-weight: ${theme.fontWeights.bold};
`;

const label = (theme) => `
  font-family: ${theme.fonts.heading};
  font-size: ${theme.fontSizes.body};
  font-weight: ${theme.fontWeights.medium};
`;

const variants = {
  body,
  hint,
  error,
  label,
  caption,
  title,
  h5,
  h4,
  h3,
  h2,
  h1,
};

export const CustomText = styled(Text)`
  ${({ theme }) => defaultTextStyles(theme)};
  ${({ variant, theme }) => variants[variant](theme)};
`;

CustomText.defaultProps = {
  variant: "body",
};


// File: /Users/vickerszhu/Projects/seat-master-js/src/features/customer/reservations/components/ReservationLayoutView.js
// src/features/customer/reservations/components/ReservationLayoutView.js
import React, { useState, useEffect, useCallback } from "react";
import { View, TouchableOpacity, Alert } from "react-native";
import styled from "styled-components/native";
import { MaterialIcons } from "@expo/vector-icons";
import { CustomText } from "../../../../components/CustomText/CustomText";
import WebApp from "../../../../components/WebApp/WebApp";
import ErrorBoundary from "../../../../components/ErrorBoundary/ErrorBoundary";

const Container = styled.View`
  min-height: 250px;
  margin-bottom: ${(props) => props.theme.space[3]};
  border-radius: 8px;
  overflow: hidden;
  background-color: ${(props) => props.theme.colors.bg.secondary};
`;

const InfoBar = styled.View`
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  padding: ${(props) => props.theme.space[2]};
  background-color: ${(props) => props.theme.colors.ui.tertiary};
`;

const InfoText = styled(CustomText)`
  font-size: ${(props) => props.theme.fontSizes.caption};
  color: ${(props) => props.theme.colors.text.secondary};
`;

const PartyLimitText = styled(CustomText)`
  font-size: ${(props) => props.theme.fontSizes.caption};
  color: ${(props) => props.theme.colors.text.error};
  font-weight: bold;
`;

const SelectedSeats = styled(CustomText)`
  font-weight: ${(props) => props.theme.fontWeights.bold};
  color: ${(props) => props.theme.colors.text.primary};
`;

const LegendContainer = styled.View`
  flex-direction: row;
  flex-wrap: wrap;
  padding: ${(props) => props.theme.space[2]};
  background-color: ${(props) => props.theme.colors.bg.primary};
  border-top-width: 1px;
  border-top-color: ${(props) => props.theme.colors.ui.tertiary};
`;

const LegendItem = styled.View`
  flex-direction: row;
  align-items: center;
  margin-right: ${(props) => props.theme.space[3]};
  margin-bottom: ${(props) => props.theme.space[1]};
`;

const LegendColor = styled.View`
  width: 12px;
  height: 12px;
  border-radius: 6px;
  margin-right: ${(props) => props.theme.space[1]};
  background-color: ${(props) => props.color};
`;

const LegendText = styled(CustomText)`
  font-size: ${(props) => props.theme.fontSizes.caption};
`;

/**
 * ReservationLayoutView component for selecting seats in the restaurant layout
 *
 * @param {Object} props - Component props
 * @param {Function} props.onTableSelect - Callback function when seats are selected
 * @param {number} props.partySize - Number of people in the party
 * @param {string} props.selectedTime - Selected reservation time (e.g. "19:00")
 * @param {string} props.selectedDate - Selected reservation date (formatted as YYYY-MM-DD)
 * @param {Function} props.onInteractionStart - Callback when interaction with layout starts
 * @param {Function} props.onInteractionEnd - Callback when interaction with layout ends
 * @returns {JSX.Element} The reservation layout component
 */
const ReservationLayoutView = ({
  onTableSelect,
  partySize,
  selectedTime,
  selectedDate,
  onInteractionStart,
  onInteractionEnd,
}) => {
  // State to track selected seats
  const [selectedItems, setSelectedItems] = useState([]);

  // Reset selections when party size changes
  useEffect(() => {
    setSelectedItems([]);
    if (onTableSelect) {
      onTableSelect(null);
    }
  }, [partySize, onTableSelect]);

  /**
   * Handle selection of chairs/seats from the WebApp
   * @param {Array} items - Array of selected seat IDs
   */
  const handleWebAppSelection = useCallback(
    (items) => {
      // Handle party size limitations
      if (items.length > partySize) {
        // Keep the most recent selections up to the party size limit
        const limitedItems = items.slice(-partySize);

        // Notify user about the limit
        Alert.alert(
          "Selection Limit Reached",
          `You can only select ${partySize} ${
            partySize === 1 ? "seat" : "seats"
          } based on your party size.`
        );

        // Update internal state
        setSelectedItems(limitedItems);

        // Notify parent component about selected items
        if (onTableSelect) {
          onTableSelect(limitedItems.join(","));
        }
      } else {
        // Normal selection within limits
        setSelectedItems(items);

        // Notify parent component
        if (items.length > 0 && onTableSelect) {
          onTableSelect(items.join(","));
        } else if (onTableSelect) {
          onTableSelect(null);
        }
      }
    },
    [partySize, onTableSelect]
  );

  return (
    <Container>
      <InfoBar>
        <InfoText>
          Preview available seats for {partySize}{" "}
          {partySize === 1 ? "person" : "people"} at {selectedTime}
        </InfoText>
        {selectedItems.length > 0 ? (
          <SelectedSeats>
            Selected: {selectedItems.join(", ")}
            {selectedItems.length < partySize &&
              ` (${partySize - selectedItems.length} more needed)`}
          </SelectedSeats>
        ) : (
          <PartyLimitText>Please select up to {partySize} seats</PartyLimitText>
        )}
      </InfoBar>

      <ErrorBoundary>
        <WebApp
          onInteractionStart={onInteractionStart}
          onInteractionEnd={onInteractionEnd}
          selectedItems={selectedItems}
          onSelectedItemsChange={handleWebAppSelection}
        />
      </ErrorBoundary>

      <LegendContainer>
        <LegendItem>
          <LegendColor color="#4CAF50" />
          <LegendText>Selected</LegendText>
        </LegendItem>
        <LegendItem>
          <LegendColor color="#F44336" />
          <LegendText>Occupied</LegendText>
        </LegendItem>
        <LegendItem>
          <LegendColor color="#FFC107" />
          <LegendText>Reserved</LegendText>
        </LegendItem>
      </LegendContainer>
    </Container>
  );
};

export default ReservationLayoutView;


// File: /Users/vickerszhu/Projects/seat-master-js/src/components/WebApp/WebApp.js
// src/components/WebApp/WebApp.js
import React, { useEffect, useRef, useState, useCallback } from "react";
import { View, ActivityIndicator } from "react-native";
import { WebView } from "react-native-webview";
import styled from "styled-components/native";
import useStaticServer from "./useStaticServer";
import {
  Container,
  StyledWebView,
  Footer,
  SelectedText,
  CancelButton,
  CancelButtonText,
} from "./styles";

const WebApp = ({
  onInteractionStart,
  onInteractionEnd,
  onSelectedItemsChange,
  selectedItems: initialSelectedItems = [],
}) => {
  const serverUrl = useStaticServer();
  const webViewRef = useRef(null);
  const [webViewHeight, setWebViewHeight] = useState(200);
  const [internalSelectedItems, setInternalSelectedItems] =
    useState(initialSelectedItems);
  const [occupiedItems, setOccupiedItems] = useState(["CHAIR1", "CHAIR4"]);
  const [isServerReady, setIsServerReady] = useState(false);
  const [currentModel, setCurrentModel] = useState("kitchen");
  const [availableItems, setAvailableItems] = useState([]);
  const [isInitialized, setIsInitialized] = useState(false);

  useEffect(() => {
    if (serverUrl) {
      setIsServerReady(true);
    }
  }, [serverUrl]);

  const cancelSelection = () => {
    setInternalSelectedItems([]);
    if (onSelectedItemsChange) {
      onSelectedItemsChange([]);
    }
  };

  const sendItemsToWebView = useCallback(() => {
    if (webViewRef.current) {
      const script = `
        (function() {
          if (window.updateItems) {
            window.updateItems({
              selectedItems: ${JSON.stringify(internalSelectedItems)},
              occupiedItems: ${JSON.stringify(occupiedItems)}
            });
          }
        })();
        true;
      `;
      webViewRef.current.injectJavaScript(script);
    }
  }, [internalSelectedItems, occupiedItems]);

  useEffect(() => {
    if (isInitialized) {
      sendItemsToWebView();
    }
  }, [internalSelectedItems, occupiedItems, sendItemsToWebView, isInitialized]);

  const handleWebViewLoaded = useCallback(() => {
    setIsInitialized(true);
    setTimeout(() => {
      sendItemsToWebView();
    }, 300);
  }, [sendItemsToWebView]);

  const changeRestaurantModel = useCallback(
    (modelKey) => {
      if (webViewRef.current) {
        const script = `
        (function() {
          if (window.changeRestaurantModel) {
            window.changeRestaurantModel('${modelKey}');
          }
        })();
        true;
      `;
        webViewRef.current.injectJavaScript(script);
        setCurrentModel(modelKey);
        setInternalSelectedItems([]);
        if (onSelectedItemsChange) {
          onSelectedItemsChange([]);
        }
      }
    },
    [onSelectedItemsChange]
  );

  const handleWebViewMessage = useCallback(
    (event) => {
      try {
        const messageData = JSON.parse(event.nativeEvent.data);
        switch (messageData.type) {
          case "itemClicked":
            if (occupiedItems.includes(messageData.id)) {
              return;
            }

            const newSelectedItems = internalSelectedItems.includes(
              messageData.id
            )
              ? internalSelectedItems.filter((id) => id !== messageData.id)
              : [...internalSelectedItems, messageData.id];

            setInternalSelectedItems(newSelectedItems);
            if (onSelectedItemsChange) {
              onSelectedItemsChange(newSelectedItems);
            }
            break;

          case "contentHeight":
            const height = Number(messageData.height);
            if (height > 0 && height !== webViewHeight) {
              setWebViewHeight(height);
            }
            break;

          case "interactionStart":
            if (onInteractionStart) {
              onInteractionStart();
            }
            break;

          case "interactionEnd":
            if (onInteractionEnd) {
              onInteractionEnd();
            }
            break;

          case "modelChanged":
            setAvailableItems(messageData.availableItems || []);
            setCurrentModel(messageData.modelKey);
            setInternalSelectedItems([]);
            if (onSelectedItemsChange) {
              onSelectedItemsChange([]);
            }
            break;

          case "webViewReady":
            handleWebViewLoaded();
            console.log("WebView is ready");
            break;

          default:
            console.warn("Unhandled message type:", messageData.type);
        }
      } catch (error) {
        console.error("Failed to parse message from WebView:", error);
      }
    },
    [
      occupiedItems,
      webViewHeight,
      onInteractionStart,
      onInteractionEnd,
      onSelectedItemsChange,
      internalSelectedItems,
    ]
  );

  return (
    <View style={{ flex: 1 }}>
      {isServerReady ? (
        <Container height={webViewHeight}>
          <StyledWebView
            ref={webViewRef}
            source={{ uri: serverUrl }}
            scrollEnabled={false}
            cacheEnabled={false}
            cacheMode="LOAD_NO_CACHE"
            incognito={true}
            thirdPartyCookiesEnabled={false}
            originWhitelist={["*"]}
            onError={(syntheticEvent) => {
              const { nativeEvent } = syntheticEvent;
              console.warn("WebView error: ", nativeEvent);
            }}
            onMessage={handleWebViewMessage}
            onLoadEnd={() => {
              sendItemsToWebView();
            }}
          />
        </Container>
      ) : (
        <View
          style={{ flex: 1, justifyContent: "center", alignItems: "center" }}
        >
          <ActivityIndicator size="large" color="#0000ff" />
        </View>
      )}
      <Footer>
        <SelectedText>
          Selected Items: {internalSelectedItems.join(", ") || "None"}
        </SelectedText>
        <CancelButton onPress={cancelSelection}>
          <CancelButtonText>Cancel Selection</CancelButtonText>
        </CancelButton>
      </Footer>
    </View>
  );
};

export default WebApp;


// File: /Users/vickerszhu/Projects/seat-master-js/src/components/WebApp/useStaticServer.js
// src/components/WebApp/useStaticServer.js
import { useEffect, useState } from "react";
import StaticServer from "react-native-static-server";
import RNFS from "react-native-fs";

const useStaticServer = () => {
  const [url, setUrl] = useState("");

  useEffect(() => {
    let server = null;

    const startServer = async () => {
      const path = `${RNFS.MainBundlePath}/3d_build`; // Ensure this path exists and contains your web app
      console.log(`Inner webapp path verified: ${path}`);

      // Generate a random port between 8000 and 9000 to avoid caching issues
      const randomPort = Math.floor(Math.random() * 1000) + 8000;

      // Add a cache-busting timestamp query parameter
      const timestamp = Date.now();

      server = new StaticServer(randomPort, path, { localOnly: true });
      try {
        let serverUrl = await server.start();
        // Append cache-busting parameter
        serverUrl = `${serverUrl}?t=${timestamp}`;
        setUrl(serverUrl);
        console.log(`Server hosting at: ${serverUrl}`);
      } catch (error) {
        console.error("Failed to start server:", error);
      }
    };

    startServer();

    // Cleanup: stop the server when the component unmounts
    return () => {
      if (server) {
        server.stop();
      }
    };
  }, []);

  return url;
};

export default useStaticServer;


// File: /Users/vickerszhu/Projects/seat-master-js/src/components/WebApp/styles.js
// src/components/WebApp/styles.js
import styled from "styled-components/native";
import { WebView } from "react-native-webview";
import { TouchableOpacity, Text, View } from "react-native";

// Container for WebView with dynamic height
export const Container = styled.View`
  width: 100%;
  height: ${({ height }) => height}px;
  background-color: ${({ theme }) => theme.colors.bg.primary};
`;

// Styled WebView
export const StyledWebView = styled(WebView)`
  flex: 1;
  width: 100%;
`;

// Footer container
export const Footer = styled.View`
  padding: ${({ theme }) => theme.space[3]};
  background-color: ${({ theme }) => theme.colors.ui.tertiary};
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
`;

// Text displaying selected chairs
export const SelectedText = styled(Text)`
  flex: 1;
  margin-right: ${({ theme }) => theme.space[2]};
  color: ${({ theme }) => theme.colors.text.primary};
  font-size: ${({ theme }) => theme.fontSizes.body};
  font-family: ${({ theme }) => theme.fonts.body};
`;

// Cancel button
export const CancelButton = styled(TouchableOpacity)`
  padding: ${({ theme }) => theme.space[2]};
  background-color: ${({ theme }) => theme.colors.ui.error};
  border-radius: 4px;
`;

// Text inside the Cancel button
export const CancelButtonText = styled(Text)`
  color: ${({ theme }) => theme.colors.text.inverse};
  font-size: ${({ theme }) => theme.fontSizes.button};
  font-family: ${({ theme }) => theme.fonts.body};
  text-align: center;
`;


// File: /Users/vickerszhu/Projects/seat-master-js/src/components/ErrorBoundary/ErrorBoundary.js
// components/ErrorBoundary.js
import React from "react";
import { TouchableOpacity } from "react-native";
import styled from "styled-components/native";

/**
 * ErrorBoundary Component
 * Catches JavaScript errors in its child component tree, logs those errors,
 * and displays a fallback UI instead of the component tree that crashed.
 */
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  /**
   * Update state so the next render will show the fallback UI.
   * @param {Error} error - The error that was thrown.
   */
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  /**
   * You can also log the error to an error reporting service.
   * @param {Error} error - The error that was thrown.
   * @param {Object} errorInfo - Additional information about the error.
   */
  componentDidCatch(error, errorInfo) {
    this.setState({ errorInfo });
    // Example: Log error to an external service
    console.error("ErrorBoundary caught an error:", error, errorInfo);
    // You can integrate services like Sentry or Bugsnag here.
  }

  /**
   * Optionally, provide a method to reset the error state.
   */
  resetError = () => {
    this.setState({ hasError: false, error: null, errorInfo: null });
  };

  render() {
    if (this.state.hasError) {
      // Render any custom fallback UI
      return (
        <ErrorContainer>
          <ErrorTitle>Something went wrong.</ErrorTitle>
          <ErrorMessage>
            We're sorry for the inconvenience. Please try again later.
          </ErrorMessage>
          {/* Optional: Button to reset the error state */}
          <RetryButton onPress={this.resetError}>
            <RetryButtonText>Try Again</RetryButtonText>
          </RetryButton>
          {/* Optional: Display error details in development mode */}
          {__DEV__ && this.state.errorInfo && (
            <ErrorDetails>
              <ErrorDetailsTitle>Error Details:</ErrorDetailsTitle>
              <ErrorDetailsText>{this.state.error.toString()}</ErrorDetailsText>
              <ErrorDetailsText>
                {this.state.errorInfo.componentStack}
              </ErrorDetailsText>
            </ErrorDetails>
          )}
        </ErrorContainer>
      );
    }

    // If no error, render children components normally
    return this.props.children;
  }
}

// Styled Components for the ErrorBoundary UI
const ErrorContainer = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  padding: ${({ theme }) => theme.space[3]};
  background-color: ${({ theme }) => theme.colors.bg.secondary};
`;

const ErrorTitle = styled.Text`
  font-size: ${({ theme }) => theme.fontSizes.title};
  font-weight: ${({ theme }) => theme.fontWeights.bold};
  color: ${({ theme }) => theme.colors.text.error};
  margin-bottom: ${({ theme }) => theme.space[2]};
`;

const ErrorMessage = styled.Text`
  font-size: ${({ theme }) => theme.fontSizes.body};
  color: ${({ theme }) => theme.colors.text.primary};
  text-align: center;
  margin-bottom: ${({ theme }) => theme.space[3]};
`;

const RetryButton = styled(TouchableOpacity)`
  padding-vertical: ${({ theme }) => theme.space[2]};
  padding-horizontal: ${({ theme }) => theme.space[3]};
  background-color: ${({ theme }) => theme.colors.ui.primary};
  border-radius: 5px;
`;

const RetryButtonText = styled.Text`
  font-size: ${({ theme }) => theme.fontSizes.button};
  color: ${({ theme }) => theme.colors.text.inverse};
  font-weight: ${({ theme }) => theme.fontWeights.bold};
`;

const ErrorDetails = styled.View`
  margin-top: ${({ theme }) => theme.space[3]};
  padding: ${({ theme }) => theme.space[2]};
  background-color: #f8d7da;
  border-radius: 5px;
`;

const ErrorDetailsTitle = styled.Text`
  font-size: ${({ theme }) => theme.fontSizes.body};
  font-weight: ${({ theme }) => theme.fontWeights.bold};
  color: ${({ theme }) => theme.colors.text.error};
  margin-bottom: ${({ theme }) => theme.space[1]};
`;

const ErrorDetailsText = styled.Text`
  font-size: ${({ theme }) => theme.fontSizes.caption};
  color: ${({ theme }) => theme.colors.text.error};
`;

export default ErrorBoundary;


// File: /Users/vickerszhu/Projects/seat-master-js/src/components/TimeScroll/TimeScroll.js
// src/components/TimeScroll/TimeScroll.js
import React, { useRef } from "react";
import styled from "styled-components/native";
import { Animated } from "react-native";
import { LinearGradient } from "expo-linear-gradient";

const ITEM_HEIGHT = 50;
const VISIBLE_ITEMS = 5;
const CONTAINER_HEIGHT = ITEM_HEIGHT * VISIBLE_ITEMS;
const CONTAINER_WIDTH = 60;
const PADDING_VERTICAL = (CONTAINER_HEIGHT - ITEM_HEIGHT) / 2;

const Container = styled.View`
  height: ${CONTAINER_HEIGHT}px;
  width: ${CONTAINER_WIDTH}px;
  background-color: ${(props) => props.theme.colors.bg.secondary};
  overflow: hidden;
  border-radius: 30px;
  position: relative;
`;

const StyledAnimatedItem = styled(Animated.View)`
  height: ${ITEM_HEIGHT}px;
  justify-content: center;
  align-items: center;
`;

const TimeText = styled.Text`
  color: ${(props) => props.theme.colors.text.primary};
  font-size: 18px;
  font-family: ${(props) => props.theme.fonts.body};
`;

export const TimeScroll = ({
  times,
  selectedTime,
  onTimeChange,
  containerHeight = CONTAINER_HEIGHT,
  containerWidth = CONTAINER_WIDTH,
  itemHeight = ITEM_HEIGHT,
  visibleItems = VISIBLE_ITEMS,
}) => {
  const scrollY = useRef(new Animated.Value(0)).current;
  const paddingVertical = (containerHeight - itemHeight) / 2;

  const handleMomentumScrollEnd = (event) => {
    const offsetY = event.nativeEvent.contentOffset.y;
    const index = Math.round(offsetY / itemHeight);
    if (index >= 0 && index < times.length) {
      onTimeChange(times[index]);
    }
  };

  return (
    <Container style={{ height: containerHeight, width: containerWidth }}>
      <Animated.ScrollView
        contentContainerStyle={{ paddingVertical: paddingVertical }}
        showsVerticalScrollIndicator={false}
        snapToInterval={itemHeight}
        decelerationRate="fast"
        bounces={false}
        onMomentumScrollEnd={handleMomentumScrollEnd}
        onScroll={Animated.event(
          [{ nativeEvent: { contentOffset: { y: scrollY } } }],
          { useNativeDriver: true }
        )}
        scrollEventThrottle={16}
      >
        {times.map((time, index) => {
          const inputRange = [
            (index - 1) * itemHeight,
            index * itemHeight,
            (index + 1) * itemHeight,
          ];

          const scale = scrollY.interpolate({
            inputRange,
            outputRange: [0.7, 1, 0.7],
            extrapolate: "clamp",
          });

          const opacity = scrollY.interpolate({
            inputRange,
            outputRange: [0.3, 1, 0.3],
            extrapolate: "clamp",
          });

          const rotateX = scrollY.interpolate({
            inputRange,
            outputRange: ["30deg", "0deg", "-30deg"],
            extrapolate: "clamp",
          });

          return (
            <StyledAnimatedItem
              key={index}
              style={{
                height: itemHeight,
                transform: [{ perspective: 1000 }, { rotateX }, { scale }],
                opacity,
              }}
            >
              <TimeText>{time}</TimeText>
            </StyledAnimatedItem>
          );
        })}
      </Animated.ScrollView>
      {/* Top gradient */}
      <LinearGradient
        colors={["rgba(241,241,241,1)", "rgba(241,241,241,0)"]}
        style={{
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          height: 20,
        }}
        pointerEvents="none"
      />
      {/* Bottom gradient */}
      <LinearGradient
        colors={["rgba(241,241,241,0)", "rgba(241,241,241,1)"]}
        style={{
          position: "absolute",
          bottom: 0,
          left: 0,
          right: 0,
          height: 20,
        }}
        pointerEvents="none"
      />
    </Container>
  );
};

export default TimeScroll;


// File: /Users/vickerszhu/Projects/seat-master-js/src/components/Separator/Separator.js
// src/components/Separator/Separator.js

import React from "react";
import PropTypes from "prop-types";
import { SeparatorFull, SeparatorPartial } from "./Separator.styles";

export const Separator = ({ type }) => {
  return type === "full" ? <SeparatorFull /> : <SeparatorPartial />;
};

Separator.propTypes = {
  type: PropTypes.oneOf(["full", "partial"]),
};


// File: /Users/vickerszhu/Projects/seat-master-js/src/components/Separator/Separator.styles.js
// src/components/Separator/Separator.styles.js

import styled from "styled-components/native";

export const SeparatorFull = styled.View`
  height: 1px;
  background-color: rgba(0, 0, 0, 0.1);
  width: 100%;
  margin-vertical: ${(props) => props.theme.space[3]};
`;

export const SeparatorPartial = styled.View`
  height: 1px;
  background-color: rgba(0, 0, 0, 0.1);
  width: 80%;
  margin-vertical: ${(props) => props.theme.space[2]};
  margin-left: 66px;
`;


// File: /Users/vickerszhu/Projects/seat-master-js/src/components/Spacer/Spacer.js
import React from 'react';
import { View } from 'react-native';
import styled, { useTheme } from 'styled-components/native';

const sizeVariant = {
  small: 1,
  medium: 2,
  large: 3,
  xl: 4,
  xxl: 5,
};

const positionVariant = {
  top: 'marginTop',
  left: 'marginLeft',
  right: 'marginRight',
  bottom: 'marginBottom',
};

const getVariant = (position, size, theme) => {
  const sizeIndex = sizeVariant[size];
  const property = positionVariant[position];
  const value = theme.space[sizeIndex];

  return `${property}:${value}`;
};

const SpacerView = styled(View)`
  ${({ variant }) => variant};
`;

export const Spacer = ({ position = 'top', size = 'small', children }) => {
  const theme = useTheme();
  const variant = getVariant(position, size, theme);

  return <SpacerView variant={variant}>{children}</SpacerView>;
};

// File: /Users/vickerszhu/Projects/seat-master-js/src/features/merchant/reservations/utils/timeUtils.js
// src/features/merchant/reservations/utils/timeUtils.js

/**
 * Generate time slots from 9:00 to 22:30 in 30-minute intervals
 * @returns {Array} Array of time strings in format "HH:MM"
 */
export const generateTimeSlots = () => {
  const slots = [];
  for (let hour = 9; hour <= 22; hour++) {
    const hourStr = hour.toString().padStart(2, "0");
    slots.push(`${hourStr}:00`);
    slots.push(`${hourStr}:30`);
  }
  return slots;
};

/**
 * Calculate position of current time indicator in the grid
 * @param {number} timeSlotHeight - Height of a single time slot in pixels
 * @returns {number} Vertical position for the current time indicator
 */
export const calculateCurrentTimePosition = (timeSlotHeight) => {
  const now = new Date();
  const hours = now.getHours();
  const minutes = now.getMinutes();

  // If outside business hours (9AM-10:30PM), return a position that's off-screen
  if (hours < 9 || (hours === 22 && minutes > 30) || hours > 22) {
    return -100;
  }

  const minutesSince9AM = (hours - 9) * 60 + minutes;
  return (minutesSince9AM / 30) * timeSlotHeight;
};

/**
 * Parse a time string into hours and minutes
 * @param {string} timeString - Time in format "HH:MM"
 * @returns {Array} Array containing [hours, minutes] as numbers
 */
export const parseTimeString = (timeString) => {
  return timeString.split(":").map(Number);
};

/**
 * Convert time to minutes since 9AM (start of business day)
 * @param {string} timeString - Time in format "HH:MM"
 * @returns {number} Minutes since 9AM
 */
export const convertToMinutesSince9AM = (timeString) => {
  const [hours, minutes] = parseTimeString(timeString);
  return (hours - 9) * 60 + minutes;
};

/**
 * Calculate time slot index for a given time
 * @param {string} timeString - Time in format "HH:MM"
 * @returns {number} Index in the time slots array
 */
export const getTimeSlotIndex = (timeString) => {
  const minutesSince9AM = convertToMinutesSince9AM(timeString);
  return Math.floor(minutesSince9AM / 30);
};

/**
 * Format a Date object to HH:MM string
 * @param {Date} date - Date object
 * @returns {string} Formatted time string
 */
export const formatTimeFromDate = (date) => {
  const hours = date.getHours().toString().padStart(2, "0");
  const minutes = date.getMinutes().toString().padStart(2, "0");
  return `${hours}:${minutes}`;
};

/**
 * Generate an array of times for the current day in hourly increments
 * @param {number} count - Number of time slots to generate
 * @returns {Array} Array of time strings in format "HH:MM"
 */
export const generateCurrentDayTimes = (count = 5) => {
  let timesArray = [];
  let current = new Date();
  current.setSeconds(0);
  current.setMilliseconds(0);

  // Round to nearest 30 minutes
  const minutes = current.getMinutes();
  current.setMinutes(minutes >= 30 ? 30 : 0);

  for (let i = 0; i < count; i++) {
    timesArray.push(formatTimeFromDate(current));
    current.setMinutes(current.getMinutes() + 30);
  }
  return timesArray;
};


// File: /Users/vickerszhu/Projects/seat-master-js/src/features/customer/reservations/screens/ReservationFlow.styles.js
// src/features/customer/reservations/screens/ReservationFlow.styles.js
import styled from "styled-components/native";
import { CustomText } from "../../../../components/CustomText/CustomText";

export const Container = styled.ScrollView`
  flex: 1;
  background-color: ${(props) => props.theme.colors.bg.primary};
  padding-horizontal: ${(props) => props.theme.space[3]};
`;

export const HeaderContainer = styled.View`
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  margin-top: ${(props) => props.theme.space[3]};
  margin-bottom: ${(props) => props.theme.space[3]};
`;

// Enhanced Date Selector
export const DateSelectorContainer = styled.View`
  margin-bottom: ${(props) => props.theme.space[3]};
`;

export const DateItemsContainer = styled.View`
  margin-vertical: ${(props) => props.theme.space[2]};
`;

export const DateOption = styled.TouchableOpacity`
  padding-vertical: ${(props) => props.theme.space[2]};
  padding-horizontal: ${(props) => props.theme.space[3]};
  margin-right: ${(props) => props.theme.space[2]};
  background-color: ${(props) =>
    props.selected
      ? props.theme.colors.ui.primary
      : props.theme.colors.bg.secondary};
  border-radius: 20px;
  min-width: 80px;
  align-items: center;
  ${(props) =>
    props.unavailable &&
    `
    opacity: 0.5;
  `}
  elevation: ${(props) => (props.selected ? 3 : 0)};
  shadow-opacity: ${(props) => (props.selected ? 0.2 : 0)};
  shadow-radius: 4px;
  shadow-color: #000;
  shadow-offset: 0px 2px;
`;

export const DateText = styled(CustomText)`
  color: ${(props) =>
    props.selected
      ? props.theme.colors.text.inverse
      : props.theme.colors.text.primary};
  font-size: ${(props) => props.theme.fontSizes.caption};
  font-weight: ${(props) =>
    props.selected
      ? props.theme.fontWeights.bold
      : props.theme.fontWeights.regular};
`;

export const WeekdayText = styled(CustomText)`
  color: ${(props) =>
    props.selected
      ? props.theme.colors.text.inverse
      : props.theme.colors.text.secondary};
  font-size: ${(props) => props.theme.fontSizes.caption};
  margin-top: 2px;
`;

export const AvailabilityIndicator = styled.View`
  width: 6px;
  height: 6px;
  border-radius: 3px;
  margin-top: 2px;
  background-color: ${(props) => {
    if (props.selected) return props.theme.colors.text.inverse;
    switch (props.level) {
      case "high":
        return "#4CAF50";
      case "medium":
        return "#FFC107";
      case "low":
        return "#F44336";
      default:
        return "#BDBDBD";
    }
  }};
`;

// Enhanced Party Size Selector
export const PartySelectorContainer = styled.View`
  margin-bottom: ${(props) => props.theme.space[3]};
`;

export const PartyOptionsContainer = styled.View`
  flex-direction: row;
  flex-wrap: wrap;
  margin-top: ${(props) => props.theme.space[2]};
`;

export const PartyOption = styled.TouchableOpacity`
  min-width: 50px;
  height: 50px;
  margin-right: ${(props) => props.theme.space[2]};
  margin-bottom: ${(props) => props.theme.space[2]};
  background-color: ${(props) =>
    props.selected
      ? props.theme.colors.ui.primary
      : props.theme.colors.bg.secondary};
  border-radius: 25px;
  align-items: center;
  justify-content: center;
  elevation: ${(props) => (props.selected ? 3 : 0)};
  shadow-opacity: ${(props) => (props.selected ? 0.2 : 0)};
  shadow-radius: 4px;
  shadow-color: #000;
  shadow-offset: 0px 2px;
`;

export const PartyText = styled(CustomText)`
  color: ${(props) =>
    props.selected
      ? props.theme.colors.text.inverse
      : props.theme.colors.text.primary};
  font-size: ${(props) => props.theme.fontSizes.body};
  font-weight: ${(props) =>
    props.selected
      ? props.theme.fontWeights.bold
      : props.theme.fontWeights.regular};
`;

// Enhanced Time Selector
export const TimeContainer = styled.View`
  margin-bottom: ${(props) => props.theme.space[3]};
`;

export const TimeOptionsContainer = styled.View`
  flex-direction: row;
  flex-wrap: wrap;
  margin-top: ${(props) => props.theme.space[2]};
`;

export const TimeOption = styled.TouchableOpacity`
  min-width: 80px;
  padding-vertical: ${(props) => props.theme.space[2]};
  padding-horizontal: ${(props) => props.theme.space[2]};
  margin-right: ${(props) => props.theme.space[2]};
  margin-bottom: ${(props) => props.theme.space[2]};
  background-color: ${(props) =>
    props.selected
      ? props.theme.colors.ui.primary
      : props.theme.colors.bg.secondary};
  border-radius: 12px;
  align-items: center;
  justify-content: center;
  ${(props) =>
    props.availability === "low" &&
    `
    border: 1px solid #F44336;
  `}
  ${(props) =>
    props.availability === "medium" &&
    `
    border: 1px solid #FFC107;
  `}
  elevation: ${(props) => (props.selected ? 3 : 0)};
  shadow-opacity: ${(props) => (props.selected ? 0.2 : 0)};
  shadow-radius: 4px;
  shadow-color: #000;
  shadow-offset: 0px 2px;
`;

export const TimeText = styled(CustomText)`
  color: ${(props) =>
    props.selected
      ? props.theme.colors.text.inverse
      : props.theme.colors.text.primary};
  font-size: ${(props) => props.theme.fontSizes.body};
  font-weight: ${(props) =>
    props.selected
      ? props.theme.fontWeights.bold
      : props.theme.fontWeights.regular};
`;

export const TimeAvailabilityIndicator = styled.View`
  width: 10px;
  height: 10px;
  border-radius: 5px;
  margin-top: 4px;
  background-color: ${(props) => {
    if (props.selected) return props.theme.colors.text.inverse;
    switch (props.level) {
      case "high":
        return "#4CAF50";
      case "medium":
        return "#FFC107";
      case "low":
        return "#F44336";
      default:
        return "#BDBDBD";
    }
  }};
`;

export const AvailabilityRow = styled.View`
  flex-direction: row;
  align-items: center;
  margin-top: ${(props) => props.theme.space[2]};
`;

export const AvailabilityText = styled(CustomText)`
  font-size: ${(props) => props.theme.fontSizes.caption};
  color: ${(props) => props.theme.colors.text.secondary};
  margin-left: ${(props) => props.theme.space[1]};
`;

// Summary Section
export const SummaryContainer = styled.View`
  margin-bottom: ${(props) => props.theme.space[3]};
`;

export const SummaryBox = styled.View`
  background-color: ${(props) => props.theme.colors.bg.secondary};
  border-radius: 10px;
  padding: ${(props) => props.theme.space[3]};
  margin-bottom: ${(props) => props.theme.space[3]};
`;

export const SummaryRow = styled.View`
  flex-direction: row;
  align-items: center;
  margin-bottom: ${(props) => props.theme.space[2]};
`;

export const SummaryText = styled(CustomText)`
  margin-left: ${(props) => props.theme.space[2]};
  font-size: ${(props) => props.theme.fontSizes.body};
`;

export const ToggleButton = styled.TouchableOpacity`
  flex-direction: row;
  align-items: center;
  padding: ${(props) => props.theme.space[2]};
  background-color: ${(props) => props.theme.colors.bg.secondary};
  border-radius: 8px;
  margin-bottom: ${(props) => props.theme.space[2]};
  elevation: 1;
  shadow-opacity: 0.1;
  shadow-radius: 4px;
  shadow-color: #000;
  shadow-offset: 0px 2px;
`;

export const ToggleText = styled(CustomText)`
  font-size: ${(props) => props.theme.fontSizes.body};
  margin-left: ${(props) => props.theme.space[2]};
`;

export const LayoutContainer = styled.View`
  min-height: 250px;
  margin-bottom: ${(props) => props.theme.space[3]};
  border-radius: 12px;
  overflow: hidden;
  background-color: ${(props) => props.theme.colors.bg.secondary};
  elevation: 1;
  shadow-opacity: 0.1;
  shadow-radius: 4px;
  shadow-color: #000;
  shadow-offset: 0px 2px;
`;

export const NotesInput = styled.TextInput`
  padding: ${(props) => props.theme.space[3]};
  background-color: ${(props) => props.theme.colors.bg.secondary};
  border-radius: 12px;
  margin-bottom: ${(props) => props.theme.space[3]};
  min-height: 100px;
  color: ${(props) => props.theme.colors.text.primary};
  elevation: 1;
  shadow-opacity: 0.1;
  shadow-radius: 4px;
  shadow-color: #000;
  shadow-offset: 0px 2px;
`;

export const ReserveButton = styled.TouchableOpacity`
  background-color: ${(props) => props.theme.colors.ui.primary};
  padding: ${(props) => props.theme.space[3]};
  border-radius: 12px;
  align-items: center;
  justify-content: center;
  margin-bottom: ${(props) => props.theme.space[4]};
  elevation: 3;
  shadow-opacity: 0.2;
  shadow-radius: 4px;
  shadow-color: #000;
  shadow-offset: 0px 2px;
`;

export const ReserveButtonText = styled(CustomText)`
  color: ${(props) => props.theme.colors.text.inverse};
  font-size: ${(props) => props.theme.fontSizes.button};
  font-weight: ${(props) => props.theme.fontWeights.bold};
`;

export const SectionTitle = styled(CustomText)`
  font-size: ${(props) => props.theme.fontSizes.body};
  font-weight: ${(props) => props.theme.fontWeights.bold};
  margin-bottom: ${(props) => props.theme.space[2]};
`;

export const InfoText = styled(CustomText)`
  font-size: ${(props) => props.theme.fontSizes.caption};
  color: ${(props) => props.theme.colors.text.secondary};
  margin-bottom: ${(props) => props.theme.space[2]};
  font-style: italic;
`;


// File: /Users/vickerszhu/Projects/seat-master-js/src/components/BackButton/BackButton.js
// src/components/BackButton/BackButton.js
import React from "react";
import { TouchableOpacity } from "react-native";
import { MaterialIcons } from "@expo/vector-icons";
import { useNavigation } from "@react-navigation/native";
import styled from "styled-components/native";

const ButtonWrapper = styled.View`
  position: ${(props) => props.position || "absolute"};
  left: ${(props) => props.theme.space[2]};
  top: ${(props) => props.top || "auto"};
  z-index: 10;
`;

/**
 * A reusable back button component that navigates to the previous screen
 *
 * @param {Object} props - Component props
 * @param {Function} props.onPress - Optional custom onPress function
 * @param {string} props.position - Optional position style, defaults to "absolute"
 * @param {string} props.top - Optional top position, defaults to "auto"
 * @param {number} props.size - Optional icon size, defaults to 24
 * @param {string} props.color - Optional icon color, defaults to "#262626"
 * @returns {React.Component} BackButton component
 */
export const BackButton = ({
  onPress,
  position,
  top,
  size = 24,
  color = "#262626",
}) => {
  const navigation = useNavigation();

  const handlePress = () => {
    if (onPress) {
      onPress();
    } else {
      navigation.goBack();
    }
  };

  return (
    <ButtonWrapper position={position} top={top}>
      <TouchableOpacity onPress={handlePress}>
        <MaterialIcons name="arrow-back" size={size} color={color} />
      </TouchableOpacity>
    </ButtonWrapper>
  );
};


